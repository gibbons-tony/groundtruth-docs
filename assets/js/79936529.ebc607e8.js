"use strict";(globalThis.webpackChunkgroundtruth_docs=globalThis.webpackChunkgroundtruth_docs||[]).push([[379],{676:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"trading-agent/strategies","title":"Complete Trading Strategy Implementation Guide","description":"Comprehensive technical reference for all 10 trading strategies","source":"@site/docs/trading-agent/strategies.md","sourceDirName":"trading-agent","slug":"/trading-agent/strategies","permalink":"/groundtruth-docs/docs/trading-agent/strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/gibbonstony/ucberkeley-capstone/tree/main/docs/trading-agent/strategies.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Profit Maximization Agent","permalink":"/groundtruth-docs/docs/trading-agent/introduction"}}');var r=i(4848),t=i(8453);const l={sidebar_position:2},a="Complete Trading Strategy Implementation Guide",c={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"System Context",id:"system-context",level:2},{value:"The Commodity Producer Scenario",id:"the-commodity-producer-scenario",level:3},{value:"Harvest Cycle Management",id:"harvest-cycle-management",level:3},{value:"Multi-Year Backtesting",id:"multi-year-backtesting",level:3},{value:"Technical Indicators Explained",id:"technical-indicators-explained",level:2},{value:"RSI (Relative Strength Index)",id:"rsi-relative-strength-index",level:3},{value:"ADX (Average Directional Index)",id:"adx-average-directional-index",level:3},{value:"CV (Coefficient of Variation)",id:"cv-coefficient-of-variation",level:3},{value:"Moving Average (MA)",id:"moving-average-ma",level:3},{value:"Cost Model",id:"cost-model",level:2},{value:"Storage Cost",id:"storage-cost",level:3},{value:"Transaction Cost",id:"transaction-cost",level:3},{value:"Baseline Strategies",id:"baseline-strategies",level:2},{value:"1. Immediate Sale Strategy",id:"1-immediate-sale-strategy",level:3},{value:"2. Equal Batch Strategy",id:"2-equal-batch-strategy",level:3},{value:"3. Price Threshold Strategy",id:"3-price-threshold-strategy",level:3},{value:"4. Moving Average Strategy",id:"4-moving-average-strategy",level:3},{value:"Prediction-Based Strategies",id:"prediction-based-strategies",level:2},{value:"5. Price Threshold Predictive (Matched Pair)",id:"5-price-threshold-predictive-matched-pair",level:3},{value:"6. Moving Average Predictive (Matched Pair)",id:"6-moving-average-predictive-matched-pair",level:3},{value:"7. Expected Value Strategy (Standalone)",id:"7-expected-value-strategy-standalone",level:3},{value:"8. Consensus Strategy (Standalone)",id:"8-consensus-strategy-standalone",level:3},{value:"9. Risk-Adjusted Strategy (Standalone)",id:"9-risk-adjusted-strategy-standalone",level:3},{value:"Optimization Strategy",id:"optimization-strategy",level:2},{value:"10. Rolling Horizon MPC (Model Predictive Control)",id:"10-rolling-horizon-mpc-model-predictive-control",level:3},{value:"Academic References",id:"academic-references",level:2},{value:"Core Citations (High Impact)",id:"core-citations-high-impact",level:3},{value:"Strategy-to-Citation Mapping",id:"strategy-to-citation-mapping",level:3},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Why 3-Tier Prediction System?",id:"why-3-tier-prediction-system",level:3},{value:"Why Coefficient of Variation (CV)?",id:"why-coefficient-of-variation-cv",level:3},{value:"Why Median Instead of Mean?",id:"why-median-instead-of-mean",level:3},{value:"Why 14-Day Horizon?",id:"why-14-day-horizon",level:3},{value:"Why Harvest-Based Inventory?",id:"why-harvest-based-inventory",level:3},{value:"Force Liquidation",id:"force-liquidation",level:3},{value:"Cooldown Periods",id:"cooldown-periods",level:3},{value:"Batch Sizes",id:"batch-sizes",level:3},{value:"Parameter Optimization",id:"parameter-optimization",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"complete-trading-strategy-implementation-guide",children:"Complete Trading Strategy Implementation Guide"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Comprehensive technical reference for all 10 trading strategies"})}),"\n",(0,r.jsxs)(n.p,{children:["Based on actual Python implementation in ",(0,r.jsx)(n.code,{children:"trading_agent/production/strategies/"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#system-context",children:"System Context"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#technical-indicators-explained",children:"Technical Indicators Explained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#cost-model",children:"Cost Model"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#baseline-strategies",children:"Baseline Strategies (4)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#prediction-based-strategies",children:"Prediction-Based Strategies (5)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#optimization-strategy",children:"Optimization Strategy (1)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#academic-references",children:"Academic References"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#design-decisions",children:"Design Decisions"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"system-context",children:"System Context"}),"\n",(0,r.jsx)(n.h3,{id:"the-commodity-producer-scenario",children:"The Commodity Producer Scenario"}),"\n",(0,r.jsxs)(n.p,{children:["This trading system is designed for ",(0,r.jsx)(n.strong,{children:"commodity producers"})," (coffee and sugar farmers) who face a specific challenge:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": You harvest 50 tons of coffee in May-September. When should you sell it?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Constraints"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Storage costs"}),": 0.5% per day (inventory degrades, warehousing fees)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction costs"}),": 1% per sale (brokerage, logistics)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quality degradation"}),": Maximum 365 days before coffee goes bad"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Price volatility"}),": Coffee futures prices change daily"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited foresight"}),": You can only see 14 days ahead (forecast horizon)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Options"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sell immediately"}),": Minimize storage costs, but might miss price increases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wait for higher prices"}),": Maximize revenue, but pay storage costs and risk price declines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sell in batches"}),": Spread risk across time (dollar-cost averaging)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use forecasts"}),": If you have price predictions, can you time sales better?"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The Question"}),": Can prediction-based strategies outperform simple baseline approaches?"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"harvest-cycle-management",children:"Harvest Cycle Management"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Innovation"}),": Inventory starts at ",(0,r.jsx)(n.strong,{children:"ZERO"})," and accumulates during harvest."]}),"\n",(0,r.jsx)(n.p,{children:"Traditional approach (wrong):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 1: Start with 50 tons\nDay 2: Sell some\nDay 3: Sell more\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Realistic approach (ours):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Coffee harvest window: May 1 - September 30 (153 days)\nAnnual volume: 50 tons\n\nDaily increment during harvest:\n- 50 tons / 153 days = 0.327 tons/day\n\nDay May 1:    Inventory = 0 + 0.327 = 0.327 tons\nDay May 2:    Inventory = 0.327 + 0.327 = 0.654 tons\nDay May 3:    Inventory = 0.654 + 0.327 = 0.981 tons\n...\nDay Sep 30:   Inventory = 49.673 + 0.327 = 50.000 tons\n\nAfter harvest (Oct 1+): No new inventory, only sales\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is implemented in ",(0,r.jsx)(n.code,{children:"backtest_engine.py:53-116"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def _create_harvest_schedule(self):\n    """\n    Calculate daily inventory increments during harvest windows.\n\n    Example (Coffee):\n        - Harvest: May-September (153 days)\n        - Volume: 50 tons/year\n        - Daily increment: 50 / 153 = 0.327 tons/day\n    """\n    harvest_schedule = {}\n    for month_start, month_end in self.harvest_windows:\n        # Convert months to day-of-year\n        harvest_days = calculate_days(month_start, month_end)\n        daily_increment = self.harvest_volume / harvest_days\n        for day in harvest_days:\n            harvest_schedule[day] = daily_increment\n    return harvest_schedule\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this matters"}),": Strategies that sell aggressively early in harvest might run out of inventory later. Realistic harvest modeling ensures accurate backtesting."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"multi-year-backtesting",children:"Multi-Year Backtesting"}),"\n",(0,r.jsxs)(n.p,{children:["The system backtests strategies across ",(0,r.jsx)(n.strong,{children:"5 years"})," (2020-2024) to capture:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Different market conditions (bull markets, bear markets, sideways)"}),"\n",(0,r.jsx)(n.li,{children:"Multiple harvest cycles (5 cycles per commodity)"}),"\n",(0,r.jsx)(n.li,{children:"Seasonal patterns"}),"\n",(0,r.jsx)(n.li,{children:"Price volatility variations"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each year is treated as an independent trial for statistical testing."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"technical-indicators-explained",children:"Technical Indicators Explained"}),"\n",(0,r.jsx)(n.p,{children:"All strategies use technical indicators to analyze market conditions. Here's how they work."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"rsi-relative-strength-index",children:"RSI (Relative Strength Index)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Wilder, J. Welles (1978). ",(0,r.jsx)(n.em,{children:"New Concepts in Technical Trading Systems."})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Identify overbought/oversold conditions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Formula"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"RS = Average Gain (14 days) / Average Loss (14 days)\nRSI = 100 - (100 / (1 + RS))\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"})," (",(0,r.jsx)(n.code,{children:"indicators.py:10-36"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def calculate_rsi(prices, period=14):\n    """\n    Calculate Relative Strength Index\n\n    Args:\n        prices: Array of historical prices\n        period: RSI period (default 14)\n\n    Returns:\n        float: RSI value (0-100)\n    """\n    if len(prices) < period + 1:\n        return 50.0  # Neutral if insufficient history\n\n    # Calculate price changes\n    deltas = np.diff(prices[-period-1:])\n\n    # Separate gains and losses\n    gains = np.where(deltas greater than 0, deltas, 0)\n    losses = np.where(deltas < 0, -deltas, 0)\n\n    # Average over period\n    avg_gain = np.mean(gains)\n    avg_loss = np.mean(losses)\n\n    if avg_loss == 0:\n        return 100.0  # All gains, maximum RSI\n\n    # Calculate RS and RSI\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    return rsi\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interpretation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RSI greater than 70"}),": ",(0,r.jsx)(n.strong,{children:"Overbought"})," - Price may be too high, likely to fall soon"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RSI < 30"}),": ",(0,r.jsx)(n.strong,{children:"Oversold"})," - Price may be too low, likely to rise soon"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RSI \u2248 50"}),": ",(0,r.jsx)(n.strong,{children:"Neutral"})," - No strong signal"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Last 14 days of price changes:\n[+2, +3, -1, +5, +2, -2, +1, +4, -3, +2, +1, -1, +3, +2] cents/lb\n\nGains: [2, 3, 0, 5, 2, 0, 1, 4, 0, 2, 1, 0, 3, 2] = 25 cents total\nLosses: [0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 1, 0, 0] = 7 cents total\n\nAverage gain = 25 / 14 = 1.79\nAverage loss = 7 / 14 = 0.50\n\nRS = 1.79 / 0.50 = 3.58\nRSI = 100 - (100 / (1 + 3.58)) = 100 - 21.83 = 78.17\n\nInterpretation: RSI = 78 greater than 70 \u2192 OVERBOUGHT (sell signal)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage in strategies"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PriceThresholdStrategy"}),": If RSI greater than 70, increase batch size (sell more)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MovingAverageStrategy"}),": If RSI greater than 70 + downward crossover, sell aggressively"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"adx-average-directional-index",children:"ADX (Average Directional Index)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Source"}),": Wilder, J. Welles (1978). ",(0,r.jsx)(n.em,{children:"New Concepts in Technical Trading Systems."})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Measure trend strength (NOT direction)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Formula"})," (simplified):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Calculate True Range (TR) = max(High - Low, |High - Prev Close|, |Low - Prev Close|)\n2. Calculate Directional Movement:\n   - +DM = max(High - Prev High, 0)  if upward move\n   - -DM = max(Prev Low - Low, 0)  if downward move\n3. Calculate Directional Indicators:\n   - +DI = 100 \xd7 (+DM average / ATR)\n   - -DI = 100 \xd7 (-DM average / ATR)\n4. Calculate DX:\n   - DX = 100 \xd7 |+DI - -DI| / (+DI + -DI)\n5. ADX = Moving average of DX\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"})," (",(0,r.jsx)(n.code,{children:"indicators.py:39-86"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def calculate_adx(price_history, period=14):\n    \"\"\"\n    Calculate Average Directional Index\n\n    Args:\n        price_history: DataFrame with 'price' column (and optionally 'high'/'low')\n        period: ADX period (default 14)\n\n    Returns:\n        tuple: (adx, plus_di, minus_di)\n    \"\"\"\n    if len(price_history) < period + 1:\n        return 20.0, 0.0, 0.0  # Neutral if insufficient history\n\n    # Get high/low (use price if not available)\n    if 'high' in price_history.columns and 'low' in price_history.columns:\n        high = price_history['high'].values\n        low = price_history['low'].values\n    else:\n        high = price_history['price'].values\n        low = price_history['price'].values\n\n    close = price_history['price'].values\n\n    # Calculate True Range\n    tr = np.maximum(high[1:] - low[1:],\n                    np.maximum(abs(high[1:] - close[:-1]),\n                              abs(low[1:] - close[:-1])))\n\n    # Calculate Directional Movement\n    plus_dm = np.where((high[1:] - high[:-1]) greater than (low[:-1] - low[1:]),\n                       np.maximum(high[1:] - high[:-1], 0), 0)\n    minus_dm = np.where((low[:-1] - low[1:]) greater than (high[1:] - high[:-1]),\n                        np.maximum(low[:-1] - low[1:], 0), 0)\n\n    # Calculate Average True Range\n    atr = np.mean(tr[-period:])\n\n    if atr greater than 0:\n        # Calculate Directional Indicators\n        plus_di = 100 * np.mean(plus_dm[-period:]) / atr\n        minus_di = 100 * np.mean(minus_dm[-period:]) / atr\n    else:\n        plus_di = 0.0\n        minus_di = 0.0\n\n    # Calculate DX\n    di_sum = plus_di + minus_di\n    if di_sum greater than 0:\n        dx = 100 * abs(plus_di - minus_di) / di_sum\n        adx = dx  # Simplified (should be smoothed)\n    else:\n        adx = 0.0\n\n    return adx, plus_di, minus_di\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interpretation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ADX greater than 25"}),": ",(0,r.jsx)(n.strong,{children:"Strong trend"})," (either upward or downward)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ADX < 20"}),": ",(0,r.jsx)(n.strong,{children:"Weak trend"})," (choppy, sideways market)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"+DI greater than -DI"}),": Upward trend"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"-DI greater than +DI"}),": Downward trend"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Price data (10 days):\nHigh:  [200, 205, 210, 208, 212, 215, 218, 220, 222, 225]\nLow:   [195, 200, 205, 203, 207, 210, 213, 215, 217, 220]\nClose: [198, 203, 208, 206, 210, 213, 216, 218, 220, 223]\n\nTrue Range (last 9 days):\nTR = max(H-L, |H-PrevClose|, |L-PrevClose|)\nTR[1] = max(205-200, |205-198|, |200-198|) = max(5, 7, 2) = 7\nTR[2] = max(210-205, |210-203|, |205-203|) = max(5, 7, 2) = 7\n...\n\n+DM (upward moves):\n+DM[1] = max(205-200, 0) if (205-200) greater than (195-200) = 5\n+DM[2] = max(210-205, 0) if (210-205) greater than (200-205) = 5\n...\n\n-DM (downward moves):\n-DM[1] = 0 (upward move)\n-DM[2] = 0 (upward move)\n...\n\nATR = mean(TR) = 6.5\n+DI = 100 \xd7 mean(+DM) / ATR = 100 \xd7 4.2 / 6.5 = 64.6\n-DI = 100 \xd7 mean(-DM) / ATR = 100 \xd7 0.8 / 6.5 = 12.3\n\nDX = 100 \xd7 |64.6 - 12.3| / (64.6 + 12.3) = 100 \xd7 52.3 / 76.9 = 68.0\nADX = 68.0\n\nInterpretation: ADX = 68 greater than 25 \u2192 STRONG TREND (upward, since +DI greater than -DI)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage in strategies"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PriceThresholdStrategy"}),": If ADX greater than 25 + RSI greater than 70, very strong signal (sell more)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MovingAverageStrategy"}),": If ADX greater than 25 + price above MA, strong uptrend (hold longer)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"cv-coefficient-of-variation",children:"CV (Coefficient of Variation)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Measure forecast uncertainty (prediction confidence)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Formula"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"CV = \u03c3 / \u03bc\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u03c3 = Standard deviation of predictions"}),"\n",(0,r.jsx)(n.li,{children:"\u03bc = Median of predictions"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"})," (",(0,r.jsx)(n.code,{children:"indicators.py:110-133"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def calculate_prediction_confidence(predictions, horizon_day):\n    """\n    Calculate confidence from prediction ensemble using coefficient of variation\n\n    Args:\n        predictions: numpy array (n_paths, n_horizons)\n                    e.g., (2000 paths, 14 days)\n        horizon_day: Which horizon to evaluate (0-indexed)\n\n    Returns:\n        float: Coefficient of variation (std_dev / median)\n    """\n    if predictions is None or predictions.size == 0:\n        return 1.0  # Maximum uncertainty\n\n    if horizon_day greater than or equal to  predictions.shape[1]:\n        horizon_day = predictions.shape[1] - 1\n\n    # Get all 2,000 predictions for this day\n    day_predictions = predictions[:, horizon_day]\n\n    # Calculate median and std dev\n    median_pred = np.median(day_predictions)\n    std_dev = np.std(day_predictions)\n\n    # Coefficient of variation\n    cv = std_dev / median_pred if median_pred greater than 0 else 1.0\n\n    return cv\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interpretation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CV < 0.05 (5%)"}),": ",(0,r.jsx)(n.strong,{children:"HIGH confidence"})," - Predictions agree strongly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CV < 0.15 (15%)"}),": ",(0,r.jsx)(n.strong,{children:"MEDIUM confidence"})," - Moderate agreement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CV \u2265 0.15"}),": ",(0,r.jsx)(n.strong,{children:"LOW confidence"})," - Predictions vary widely"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"2,000 forecast paths for day 14:\nPrices range from $1.95 to $2.05 per lb\n\nMedian = $2.00\nStd dev = $0.08\n\nCV = $0.08 / $2.00 = 0.04 = 4%\n\nInterpretation: CV = 4% < 5% \u2192 HIGH CONFIDENCE\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why median instead of mean?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Robust to outliers"}),"\n",(0,r.jsx)(n.li,{children:"If 1 path predicts $10 (outlier), median unchanged"}),"\n",(0,r.jsx)(n.li,{children:"Mean would shift significantly"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage in prediction strategies"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All prediction-based strategies use CV to determine confidence level"}),"\n",(0,r.jsx)(n.li,{children:"HIGH confidence (CV < 5%): Trust predictions, override baseline"}),"\n",(0,r.jsx)(n.li,{children:"MEDIUM confidence (CV < 15%): Blend predictions with baseline"}),"\n",(0,r.jsx)(n.li,{children:"LOW confidence (CV \u2265 15%): Ignore predictions, use baseline"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"moving-average-ma",children:"Moving Average (MA)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Smooth price data to identify trend."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Formula"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"MA_n = (P_1 + P_2 + ... + P_n) / n\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"})," (30-day MA):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Last 30 prices:\n[195, 196, 198, 200, 202, 203, 205, 207, 208, 210, ...]\n\nMA_30 = (195 + 196 + ... + 210) / 30 = 202.5\n\nCurrent price = 208\nPrice vs MA = 208 / 202.5 = 1.027 = 2.7% above MA\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Crossover Detection"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Yesterday:\n  Price = 201\n  MA = 202\n  Status: Price BELOW MA\n\nToday:\n  Price = 204\n  MA = 203\n  Status: Price ABOVE MA\n\n\u2192 UPWARD CROSSOVER (price crossed UP through MA)\n\u2192 Bullish signal (trend reversing from falling to rising)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cost-model",children:"Cost Model"}),"\n",(0,r.jsx)(n.p,{children:"All strategies account for two costs:"}),"\n",(0,r.jsx)(n.h3,{id:"storage-cost",children:"Storage Cost"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rate"}),": 0.5% per day (0.005% in code)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"})," (from ",(0,r.jsx)(n.code,{children:"CHANGELOG.md:2025-12-04"}),"):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Warehouse rental"}),"\n",(0,r.jsx)(n.li,{children:"Handling fees"}),"\n",(0,r.jsx)(n.li,{children:"Quality degradation"}),"\n",(0,r.jsx)(n.li,{children:"Insurance"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"storage_cost = current_price \xd7 (0.005 / 100) \xd7 days_stored\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Price = $2.00/lb = $4,000/ton\nDays stored = 30\n\nStorage cost = $4,000 \xd7 (0.005 / 100) \xd7 30\n             = $4,000 \xd7 0.00005 \xd7 30\n             = $6.00/ton\n\nOver 30 days: $6.00/ton\nOver 365 days: $73.00/ton (1.825% of value)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transaction-cost",children:"Transaction Cost"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rate"}),": 1% per sale (0.01% in code)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Brokerage fees"}),"\n",(0,r.jsx)(n.li,{children:"Logistics (transport to warehouse/port)"}),"\n",(0,r.jsx)(n.li,{children:"Quality inspection"}),"\n",(0,r.jsx)(n.li,{children:"Documentation"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"transaction_cost = sale_price \xd7 (0.01 / 100)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Sale price = $2.00/lb = $4,000/ton\nAmount sold = 12.5 tons\n\nRevenue = 12.5 \xd7 $4,000 = $50,000\nTransaction cost = $50,000 \xd7 (0.01 / 100) = $5.00\nNet revenue = $50,000 - $5.00 = $49,995\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why these rates?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Based on diagnostic research with real producer data"}),"\n",(0,r.jsx)(n.li,{children:"Validated against industry standards"}),"\n",(0,r.jsx)(n.li,{children:"Conservative estimates (actual costs may be higher)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"baseline-strategies",children:"Baseline Strategies"}),"\n",(0,r.jsx)(n.p,{children:"Baseline strategies do NOT use forecasts. They serve as benchmarks to evaluate whether predictions add value."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"1-immediate-sale-strategy",children:"1. Immediate Sale Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"baseline.py:29-71"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Naive baseline - sell everything weekly."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Every 7 days:\n  If inventory greater than or equal to  min_batch_size:\n    Sell ALL inventory\n  Else:\n    Wait for more accumulation\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Logic"})," (",(0,r.jsx)(n.code,{children:"baseline.py:44-66"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def decide(self, day, inventory, current_price, price_history, predictions=None):\n    if inventory less than or equal to  0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_inventory'}\n\n    # Force liquidation check (365 days max)\n    forced = self._force_liquidation_check(day, inventory)\n    if forced:\n        return forced\n\n    # Check if it's time to sell\n    ready_to_sell = (self.days_since_last_sale greater than or equal to  self.sale_frequency_days)\n    enough_inventory = (inventory greater than or equal to  self.min_batch_size)\n\n    if ready_to_sell and enough_inventory:\n        self.days_since_last_sale = 0\n        return {\n            'action': 'SELL',\n            'amount': inventory,  # Sell ALL\n            'reason': f'immediate_weekly_sale_{inventory:.1f}t'\n        }\n\n    # Wait\n    self.days_since_last_sale += 1\n    if not enough_inventory:\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'accumulating_need_{self.min_batch_size:.1f}t'}\n    else:\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'waiting_for_sale_day_{self.days_since_last_sale}'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_batch_size"}),": 5.0 tons (don't sell tiny amounts)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sale_frequency_days"}),": 7 (weekly sales)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"})," (Coffee harvest):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Harvest: May 1 - Sep 30 (153 days)\nDaily increment: 50 / 153 = 0.327 tons/day\n\nDay 1 (May 1):\n  Inventory = 0.327 tons\n  Days since sale = 7\n  0.327 < 5.0 \u2192 HOLD (accumulate)\n\nDay 7 (May 7):\n  Inventory = 2.289 tons\n  Days since sale = 13\n  2.289 < 5.0 \u2192 HOLD (still accumulating)\n\nDay 15 (May 15):\n  Inventory = 4.905 tons\n  Days since sale = 21\n  4.905 < 5.0 \u2192 HOLD (almost there)\n\nDay 16 (May 16):\n  Inventory = 5.232 tons\n  Days since sale = 22\n  22 greater than or equal to  7 AND 5.232 greater than or equal to  5.0 \u2192 SELL ALL 5.232 tons\n  Days since sale reset to 0\n\nDay 23 (May 23):\n  Inventory = 2.289 tons (accumulated since last sale)\n  Days since sale = 7\n  2.289 < 5.0 \u2192 HOLD\n\n... continues weekly\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic Context"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NO specific citation"})," - This is an industry-standard naive baseline"]}),"\n",(0,r.jsx)(n.li,{children:'Represents "sell as soon as possible" farmer behavior'}),"\n",(0,r.jsx)(n.li,{children:"Minimizes storage costs"}),"\n",(0,r.jsx)(n.li,{children:"Ignores all market signals"}),"\n",(0,r.jsx)(n.li,{children:"Expected to underperform but provides lower bound"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simplest possible strategy"}),"\n",(0,r.jsx)(n.li,{children:"Easy to understand and implement"}),"\n",(0,r.jsx)(n.li,{children:"Provides baseline for comparison"}),"\n",(0,r.jsx)(n.li,{children:"If prediction strategies can't beat this, they have no value"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-equal-batch-strategy",children:"2. Equal Batch Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"baseline.py:73-108"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Systematic liquidation - sell fixed percentages on schedule."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Every 30 days:\n  Sell 25% of current inventory\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Logic"})," (",(0,r.jsx)(n.code,{children:"baseline.py:88-103"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def decide(self, day, inventory, current_price, price_history, predictions=None):\n    if inventory less than or equal to  0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_inventory'}\n\n    forced = self._force_liquidation_check(day, inventory)\n    if forced:\n        return forced\n\n    days_since_sale = day - self.last_sale_day\n\n    if days_since_sale greater than or equal to  self.frequency:\n        amount = inventory * self.batch_size\n        self.last_sale_day = day\n        return {'action': 'SELL', 'amount': amount, 'reason': 'scheduled_batch'}\n\n    return {'action': 'HOLD', 'amount': 0, 'reason': 'waiting_for_schedule'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_size"}),": 0.25 (sell 25% each time)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"frequency_days"}),": 30 (monthly batches)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 0:   Inventory = 50 tons\nDay 30:  Sell 50 \xd7 0.25 = 12.5 tons, keep 37.5\nDay 60:  Sell 37.5 \xd7 0.25 = 9.375 tons, keep 28.125\nDay 90:  Sell 28.125 \xd7 0.25 = 7.031 tons, keep 21.094\nDay 120: Sell 21.094 \xd7 0.25 = 5.274 tons, keep 15.820\nDay 150: Sell 15.820 \xd7 0.25 = 3.955 tons, keep 11.865\nDay 180: Sell 11.865 \xd7 0.25 = 2.966 tons, keep 8.899\nDay 210: Sell 8.899 \xd7 0.25 = 2.225 tons, keep 6.674\nDay 240: Sell 6.674 \xd7 0.25 = 1.669 tons, keep 5.006\nDay 270: Sell 5.006 \xd7 0.25 = 1.252 tons, keep 3.754\nDay 300: Sell 3.754 \xd7 0.25 = 0.939 tons, keep 2.816\nDay 330: Sell 2.816 \xd7 0.25 = 0.704 tons, keep 2.112\nDay 360: Sell 2.112 \xd7 0.25 = 0.528 tons, keep 1.584\nDay 365: Force liquidate remaining 1.584 tons\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic Context"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"No strong academic endorsement"})}),"\n",(0,r.jsx)(n.li,{children:"Reverse dollar-cost averaging"}),"\n",(0,r.jsx)(n.li,{children:"Research suggests this is suboptimal (reduces expected returns)"}),"\n",(0,r.jsx)(n.li,{children:"Practitioner heuristic, not research-based"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to cite"}),':\nDescribe as "systematic liquidation with periodic review" or "fixed-fraction disposal policy" without citing specific paper.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spreads risk across time"}),"\n",(0,r.jsx)(n.li,{children:"Avoids timing the market"}),"\n",(0,r.jsx)(n.li,{children:"Common real-world approach"}),"\n",(0,r.jsx)(n.li,{children:"Smooths price volatility impact"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-price-threshold-strategy",children:"3. Price Threshold Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"baseline.py:110-218"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Technical analysis baseline - sell when price crosses above MA threshold."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Calculate 30-day moving average (MA)\n2. Set threshold = MA \xd7 (1 + threshold_pct)\n3. If price greater than threshold:\n   a. Calculate RSI and ADX\n   b. Determine batch size based on indicators\n   c. Sell batch\n4. If no sale in 60 days:\n   Sell anyway (fallback)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Logic"})," (",(0,r.jsx)(n.code,{children:"baseline.py:154-188"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def decide(self, day, inventory, current_price, price_history, predictions=None):\n    if inventory less than or equal to  0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_inventory'}\n\n    forced = self._force_liquidation_check(day, inventory)\n    if forced:\n        return forced\n\n    days_since_sale = day - self.last_sale_day\n\n    # Calculate threshold based on 30-day MA\n    if len(price_history) greater than or equal to  30:\n        ma_30 = price_history['price'].tail(30).mean()\n        threshold = ma_30 * (1 + self.threshold_pct)\n    else:\n        threshold = current_price * (1 + self.threshold_pct)\n\n    signal_triggered = current_price greater than threshold\n    can_trade = days_since_sale greater than or equal to  self.cooldown_days\n\n    if not signal_triggered:\n        # Below threshold - wait\n        if days_since_sale greater than or equal to  self.max_days_without_sale:\n            # Fallback after 60 days\n            return self._execute_trade(day, inventory, self.batch_baseline,\n                                      f'fallback_{days_since_sale}d')\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'below_threshold_{current_price:.2f}<{threshold:.2f}'}\n\n    if not can_trade:\n        # Cooldown period\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'cooldown_{self.cooldown_days - days_since_sale}d'}\n\n    # Signal triggered - analyze with indicators\n    batch_size, reason = self._analyze_historical(current_price, price_history)\n    return self._execute_trade(day, inventory, batch_size, reason)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Indicator Analysis"})," (",(0,r.jsx)(n.code,{children:"baseline.py:189-208"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_historical(self, current_price, price_history):\n    \"\"\"Analyze using historical technical indicators\"\"\"\n    prices = price_history['price'].values\n    rsi = calculate_rsi(prices, period=14)\n    adx, _, _ = calculate_adx(price_history, period=14)\n\n    if rsi greater than self.rsi_overbought and adx greater than self.adx_strong:\n        # Overbought + strong trend\n        batch_size = self.batch_overbought_strong  # 0.35\n        reason = f'overbought_strong_trend_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    elif rsi greater than self.rsi_overbought:\n        # Overbought only\n        batch_size = self.batch_overbought  # 0.30\n        reason = f'overbought_rsi{rsi:.0f}'\n\n    elif adx greater than self.adx_strong and rsi < self.rsi_moderate:\n        # Strong trend but not overbought\n        batch_size = self.batch_strong_trend  # 0.20\n        reason = f'strong_trend_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    else:\n        # Baseline\n        batch_size = self.batch_baseline  # 0.25\n        reason = f'baseline_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    return batch_size, reason\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"threshold_pct"}),": 0.05 (trigger when price greater than MA \xd7 1.05)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_baseline"}),": 0.25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_overbought_strong"}),": 0.35"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_overbought"}),": 0.30"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_strong_trend"}),": 0.20"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rsi_overbought"}),": 70"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rsi_moderate"}),": 65"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"adx_strong"}),": 25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldown_days"}),": 7"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_days_without_sale"}),": 60"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Day 50:\n  Current price = $2.05/lb\n  30-day MA = $1.95/lb\n  Threshold = $1.95 \xd7 1.05 = $2.0475/lb\n\n  $2.05 greater than $2.0475 \u2192 Signal TRIGGERED\n\n  Days since last sale = 10 greater than or equal to  7 (cooldown passed)\n\n  Calculate indicators:\n    RSI = 72 (overbought)\n    ADX = 28 (strong trend)\n\n  RSI greater than 70 AND ADX greater than 25 \u2192 Overbought + strong trend\n  Batch size = 0.35 (sell 35%)\n\n  Inventory = 40 tons\n  Sell 40 \xd7 0.35 = 14 tons\n\n  Return: SELL 14 tons, reason = "overbought_strong_trend_rsi72_adx28"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wilder (1978)"})," for RSI and ADX indicators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Marshall et al. (2008)"}),' "Can commodity futures be profitably traded with quantitative market timing strategies?" ',(0,r.jsx)(n.em,{children:"Journal of Banking & Finance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Comprehensive examination of quantitative trading rules in commodity futures"}),"\n",(0,r.jsx)(n.li,{children:"Tests 15 major commodity futures series"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Brock et al. (1992)"}),' "Simple technical trading rules and the stochastic properties of stock returns" ',(0,r.jsx)(n.em,{children:"Journal of Finance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Academic validation of moving average strategies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Combines price momentum (threshold) with technical confirmation (RSI/ADX)"}),"\n",(0,r.jsx)(n.li,{children:"Cooldown prevents overtrading (transaction costs add up)"}),"\n",(0,r.jsx)(n.li,{children:"Fallback prevents holding too long in flat markets"}),"\n",(0,r.jsx)(n.li,{children:"Adaptive batch sizing based on signal strength"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-moving-average-strategy",children:"4. Moving Average Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"baseline.py:220-340"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Crossover detection - sell when price crosses down through MA."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Calculate 30-day moving average (MA)\n2. Detect crossovers:\n   - Upward cross (price crosses UP): HOLD (bullish)\n   - Downward cross (price crosses DOWN): SELL (bearish)\n3. If downward cross:\n   a. Calculate RSI and ADX\n   b. Determine batch size\n   c. Sell batch\n4. If no sale in 60 days:\n   Sell anyway (fallback)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Crossover Detection"})," (",(0,r.jsx)(n.code,{children:"baseline.py:284-310"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Get last 31 prices\nrecent_prices = price_history['price'].tail(self.period + 1).values\n\n# Calculate moving averages\nma_current = np.mean(recent_prices[-30:])  # Last 30 days\nma_prev = np.mean(recent_prices[-31:-1])   # Previous 30 days\n\nprev_price = recent_prices[-2]\n\n# Detect crossover directions\nupward_cross = (prev_price less than or equal to  ma_prev and current_price greater than ma_current)\ndownward_cross = (prev_price greater than or equal to  ma_prev and current_price < ma_current)\n\n# Upward crossover: Transition from falling to rising - HOLD\nif upward_cross:\n    return {'action': 'HOLD', 'amount': 0, 'reason': 'upward_crossover_bullish'}\n\n# Downward crossover: Transition from rising to falling - SELL\nif downward_cross:\n    if not can_trade:\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'cooldown_{self.cooldown_days - days_since_sale}d'}\n\n    # Analyze with indicators\n    batch_size, reason = self._analyze_historical(current_price, price_history)\n    return self._execute_trade(day, inventory, batch_size, reason)\n\n# No crossover: maintain position\nreturn {'action': 'HOLD', 'amount': 0, 'reason': 'no_crossover'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Indicator Analysis"})," (",(0,r.jsx)(n.code,{children:"baseline.py:312-331"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_historical(self, current_price, price_history):\n    \"\"\"Analyze using historical technical indicators\"\"\"\n    prices = price_history['price'].values\n    rsi = calculate_rsi(prices, period=14)\n    adx, _, _ = calculate_adx(price_history, period=14)\n\n    if adx greater than self.adx_strong and rsi greater than or equal to  self.rsi_min and rsi less than or equal to  self.rsi_overbought:\n        # Strong momentum\n        batch_size = self.batch_strong_momentum  # 0.20\n        reason = f'strong_momentum_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    elif rsi greater than self.rsi_overbought and adx greater than self.adx_strong:\n        # Overbought + strong trend\n        batch_size = self.batch_overbought_strong  # 0.35\n        reason = f'overbought_strong_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    elif rsi greater than self.rsi_overbought:\n        # Overbought only\n        batch_size = self.batch_overbought  # 0.30\n        reason = f'overbought_rsi{rsi:.0f}'\n\n    else:\n        # Baseline\n        batch_size = self.batch_baseline  # 0.25\n        reason = f'baseline_rsi{rsi:.0f}_adx{adx:.0f}'\n\n    return batch_size, reason\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ma_period"}),": 30 (30-day moving average)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_baseline"}),": 0.25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_strong_momentum"}),": 0.20"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_overbought_strong"}),": 0.35"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_overbought"}),": 0.30"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rsi_overbought"}),": 70"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rsi_min"}),": 45"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"adx_strong"}),": 25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"adx_weak"}),": 20"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldown_days"}),": 7"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_days_without_sale"}),": 60"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Day 75:\n  Current price = $1.98/lb\n  MA (days 45-74) = $2.02/lb\n  MA (days 46-75) = $2.00/lb\n\n  Yesterday:\n    Price = $2.03/lb\n    MA = $2.02/lb\n    Status: Price ABOVE MA\n\n  Today:\n    Price = $1.98/lb\n    MA = $2.00/lb\n    Status: Price BELOW MA\n\n  Detection: DOWNWARD CROSSOVER\n  (Price crossed DOWN through MA \u2192 Bearish signal)\n\n  Days since last sale = 12 greater than or equal to  7 (cooldown passed)\n\n  Calculate indicators:\n    RSI = 55 (neutral)\n    ADX = 30 (strong trend)\n\n  ADX greater than 25 AND RSI between 45-70 \u2192 Strong momentum\n  Batch size = 0.20 (sell 20%)\n\n  Inventory = 35 tons\n  Sell 35 \xd7 0.20 = 7 tons\n\n  Return: SELL 7 tons, reason = "strong_momentum_rsi55_adx30"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Marshall et al. (2008)"})," - Most appropriate for commodity MA strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Brock et al. (1992)"})," - Comprehensive MA study (stock-focused but validates approach)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wilder (1978)"})," - For RSI/ADX indicators"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Classic technical analysis pattern"}),"\n",(0,r.jsx)(n.li,{children:"Downward crossover signals trend reversal (rising \u2192 falling)"}),"\n",(0,r.jsx)(n.li,{children:"Upward crossover signals bullish trend (hold for higher prices)"}),"\n",(0,r.jsx)(n.li,{children:"Avoids selling into rising markets"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"prediction-based-strategies",children:"Prediction-Based Strategies"}),"\n",(0,r.jsx)(n.p,{children:"These strategies use 14-day price forecasts (2,000 Monte Carlo paths) to make decisions."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Innovation: 3-Tier Confidence System"})}),"\n",(0,r.jsx)(n.p,{children:"All prediction-based matched pairs use this system:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tier 1: HIGH Confidence (CV < 5%)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action"}),": OVERRIDE baseline completely"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logic"}),": Predictions are highly certain, trust them fully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": If predictions show strong upward trend with 4% CV, HOLD regardless of baseline signal"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tier 2: MEDIUM Confidence (CV < 15%)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action"}),": BLEND baseline + predictions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logic"}),": Moderate certainty, use both signals"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": If baseline says SELL and predictions say HOLD, reduce sell amount by 50%"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tier 3: LOW Confidence (CV \u2265 15%)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action"}),": FOLLOW baseline exactly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logic"}),": Predictions too uncertain, ignore them"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Execute baseline strategy as if predictions don't exist"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This ensures fair A/B testing between baseline and prediction-augmented strategies."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"5-price-threshold-predictive-matched-pair",children:"5. Price Threshold Predictive (Matched Pair)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"prediction.py:46-380"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Augment Price Threshold baseline with forecast-driven overrides."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Matched Pair Design"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Baseline"}),": PriceThresholdStrategy (no forecasts)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Augmented"}),": This strategy (with prediction capability)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Measure value added by predictions"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Hierarchy"})," (",(0,r.jsx)(n.code,{children:"prediction.py:124-166"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def decide(self, day, inventory, current_price, price_history, predictions=None):\n    \"\"\"\n    DECISION HIERARCHY:\n    1. Forced liquidation (always highest priority)\n    2. Cooldown check\n    3. Prediction signal analysis (if available)\n    4. Baseline signal (if no predictions or low confidence)\n    \"\"\"\n    if inventory less than or equal to  0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_inventory'}\n\n    forced = self._force_liquidation_check(day, inventory)\n    if forced:\n        return forced\n\n    days_since_sale = day - self.last_sale_day\n\n    if days_since_sale < self.cooldown_days:\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'cooldown_{self.cooldown_days - days_since_sale}d'}\n\n    # Analyze predictions if available\n    if predictions is not None and predictions.size greater than 0:\n        pred_signal = self._analyze_prediction_signal(\n            current_price, price_history, predictions\n        )\n\n        # HIGH CONFIDENCE \u2192 OVERRIDE BASELINE\n        if pred_signal['confidence'] == 'HIGH':\n            return self._execute_prediction_override(\n                day, inventory, pred_signal, price_history\n            )\n\n        # MEDIUM CONFIDENCE \u2192 BLEND WITH BASELINE\n        elif pred_signal['confidence'] == 'MEDIUM':\n            return self._execute_blended_decision(\n                day, inventory, current_price, price_history, pred_signal\n            )\n\n    # LOW/NO CONFIDENCE \u2192 FOLLOW BASELINE\n    return self._execute_baseline_logic(\n        day, inventory, current_price, price_history\n    )\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Prediction Signal Analysis"})," (",(0,r.jsx)(n.code,{children:"prediction.py:168-209"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_prediction_signal(self, current_price, price_history, predictions):\n    \"\"\"\n    Analyze predictions to determine:\n    1. Direction (upward/downward/neutral)\n    2. Magnitude (strong/moderate/weak)\n    3. Confidence (high/medium/low)\n    \"\"\"\n    # predictions is (2000 paths \xd7 14 days) matrix\n\n    # Calculate net benefit across all horizons\n    net_benefit_pct = self._calculate_net_benefit_pct(current_price, predictions)\n\n    # Calculate prediction confidence (CV at day 14)\n    day_14_predictions = predictions[:, 13]  # 2,000 values\n    median = np.median(day_14_predictions)\n    std_dev = np.std(day_14_predictions)\n    cv = std_dev / median\n\n    # Determine confidence level\n    if cv < self.high_confidence_cv:  # CV < 5%\n        confidence = 'HIGH'\n    elif cv < self.medium_confidence_cv:  # CV < 15%\n        confidence = 'MEDIUM'\n    else:\n        confidence = 'LOW'\n\n    # Determine direction and magnitude\n    if net_benefit_pct greater than self.strong_positive_threshold: 2.0 (text: greater than 2 percent net benefit)\n        direction = 'STRONG_UPWARD'\n    elif net_benefit_pct greater than self.moderate_threshold: 0.5 (text: plus or minus 0.5 percent)\n        direction = 'MODERATE_UPWARD'\n    elif net_benefit_pct < self.strong_negative_threshold: -1.0 (text: less than -1 percent net benefit)\n        direction = 'STRONG_DOWNWARD'\n    elif net_benefit_pct less than -self.moderate_threshold: 0.5 (text: plus or minus 0.5 percent)\n        direction = 'MODERATE_DOWNWARD'\n    else:\n        direction = 'NEUTRAL'\n\n    return {\n        'confidence': confidence,\n        'direction': direction,\n        'net_benefit_pct': net_benefit_pct,\n        'cv': cv\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Net Benefit Calculation"})," (",(0,r.jsx)(n.code,{children:"prediction.py:351-371"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def _calculate_net_benefit_pct(self, current_price, predictions):\n    """\n    Calculate net benefit as percentage:\n    (best_future_value - sell_today_value) / current_price * 100\n\n    Accounts for storage and transaction costs.\n    """\n    # Find optimal day to sell in 14-day window\n    ev_by_day = []\n    for day in range(14):\n        # Use median of 2,000 paths as expected price\n        future_price = np.median(predictions[:, day])\n        days_to_wait = day + 1\n\n        # Calculate costs\n        storage_cost = current_price * (self.storage_cost_pct_per_day / 100) * days_to_wait\n        transaction_cost = future_price * (self.transaction_cost_pct / 100)\n\n        # Expected value if we sell on this day\n        ev = future_price - storage_cost - transaction_cost\n        ev_by_day.append(ev)\n\n    # Compare to selling today\n    transaction_cost_today = current_price * (self.transaction_cost_pct / 100)\n    ev_today = current_price - transaction_cost_today\n\n    # Find best option\n    optimal_ev = max(ev_by_day)\n    net_benefit_pct = 100 * (optimal_ev - ev_today) / current_price\n\n    return net_benefit_pct\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"HIGH Confidence Override"})," (",(0,r.jsx)(n.code,{children:"prediction.py:211-244"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _execute_prediction_override(self, day, inventory, pred_signal, price_history):\n    \"\"\"\n    HIGH CONFIDENCE: Predictions override baseline completely\n    \"\"\"\n    direction = pred_signal['direction']\n    net_benefit = pred_signal['net_benefit_pct']\n    cv = pred_signal['cv']\n\n    if direction == 'STRONG_UPWARD':\n        # Strong evidence prices will rise \u2192 HOLD completely\n        batch_size = self.batch_pred_hold  # 0.0\n        reason = f'OVERRIDE_hold_strong_upward_net{net_benefit:.2f}%_cv{cv:.2%}'\n\n    elif direction == 'MODERATE_UPWARD':\n        # Moderate upward \u2192 Small hedge\n        batch_size = self.batch_pred_cautious  # 0.15\n        reason = f'OVERRIDE_small_hedge_mod_upward_net{net_benefit:.2f}%_cv{cv:.2%}'\n\n    elif direction == 'STRONG_DOWNWARD':\n        # Strong evidence prices will fall \u2192 SELL aggressively\n        batch_size = self.batch_pred_aggressive  # 0.40\n        reason = f'OVERRIDE_aggressive_strong_downward_net{net_benefit:.2f}%_cv{cv:.2%}'\n\n    elif direction == 'MODERATE_DOWNWARD':\n        # Moderate downward \u2192 Sell baseline\n        batch_size = self.batch_baseline  # 0.25\n        reason = f'OVERRIDE_baseline_mod_downward_net{net_benefit:.2f}%_cv{cv:.2%}'\n\n    else:  # NEUTRAL\n        # Unclear signal \u2192 Use baseline batch\n        batch_size = self.batch_baseline  # 0.25\n        reason = f'OVERRIDE_neutral_net{net_benefit:.2f}%_cv{cv:.2%}'\n\n    return self._execute_trade(day, inventory, batch_size, reason)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"MEDIUM Confidence Blend"})," (",(0,r.jsx)(n.code,{children:"prediction.py:246-283"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _execute_blended_decision(self, day, inventory, current_price, price_history, pred_signal):\n    \"\"\"\n    MEDIUM CONFIDENCE: Blend baseline signal with prediction signal\n    \"\"\"\n    # Calculate what baseline would do\n    baseline_action = self._get_baseline_action(current_price, price_history)\n\n    direction = pred_signal['direction']\n    net_benefit = pred_signal['net_benefit_pct']\n\n    # Blend logic:\n    if baseline_action['triggered']:\n        # Baseline says SELL (price above threshold)\n        if direction in ['STRONG_UPWARD', 'MODERATE_UPWARD']:\n            # Predictions disagree (say hold) \u2192 reduce sell amount\n            batch_size = baseline_action['batch_size'] * 0.5\n            reason = f'BLEND_reduce_sell_pred_upward_net{net_benefit:.2f}%'\n        else:\n            # Predictions agree or neutral \u2192 follow baseline\n            batch_size = baseline_action['batch_size']\n            reason = f'BLEND_follow_baseline_{baseline_action[\"reason\"]}'\n\n    else:\n        # Baseline says HOLD (price below threshold)\n        if direction in ['STRONG_DOWNWARD', 'MODERATE_DOWNWARD']:\n            # Predictions disagree (say sell) \u2192 cautious sell\n            batch_size = self.batch_pred_cautious  # 0.15\n            reason = f'BLEND_cautious_sell_pred_downward_net{net_benefit:.2f}%'\n        else:\n            # Predictions agree \u2192 hold\n            return {'action': 'HOLD', 'amount': 0, 'reason': 'BLEND_hold_pred_agrees'}\n\n    return self._execute_trade(day, inventory, batch_size, reason)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LOW Confidence Baseline"})," (",(0,r.jsx)(n.code,{children:"prediction.py:285-310"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _execute_baseline_logic(self, day, inventory, current_price, price_history):\n    \"\"\"\n    Execute IDENTICAL logic to PriceThresholdStrategy (for fair comparison)\n    \"\"\"\n    days_since_sale = day - self.last_sale_day\n\n    # Calculate threshold\n    if len(price_history) greater than or equal to  30:\n        ma_30 = price_history['price'].tail(30).mean()\n        threshold = ma_30 * (1 + self.threshold_pct)\n    else:\n        threshold = current_price * (1 + self.threshold_pct)\n\n    signal_triggered = current_price greater than threshold\n\n    if not signal_triggered:\n        # Fallback after 60 days\n        if days_since_sale greater than or equal to  self.max_days_without_sale:\n            return self._execute_trade(day, inventory, self.batch_baseline,\n                                      f'BASELINE_fallback_{days_since_sale}d')\n        return {'action': 'HOLD', 'amount': 0,\n               'reason': f'BASELINE_below_threshold_{current_price:.2f}<{threshold:.2f}'}\n\n    # Signal triggered \u2192 analyze with technical indicators\n    batch_size, reason = self._analyze_baseline_technicals(current_price, price_history)\n    return self._execute_trade(day, inventory, batch_size, f'BASELINE_{reason}')\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Day 80:\n  Current price = $2.05/lb\n  MA = $1.95/lb\n  Threshold = $2.0475/lb\n\n  Predictions (2,000 paths \xd7 14 days):\n    Day 14 median = $2.15/lb\n    Day 14 std dev = $0.06/lb\n    CV = $0.06 / $2.15 = 0.028 = 2.8% \u2192 HIGH CONFIDENCE\n\n  Calculate net benefit:\n    Best day to sell = Day 14\n    EV(day 14) = $2.15 - storage($0.08) - transaction($0.02) = $2.05\n    EV(today) = $2.05 - transaction($0.02) = $2.03\n    Net benefit = ($2.05 - $2.03) / $2.05 \xd7 100 = 0.98%\n\n  Signal analysis:\n    Confidence = HIGH (CV 2.8% < 5%)\n    Direction = MODERATE_UPWARD (net benefit 0.98% greater than 0.5%)\n\n  Decision: HIGH CONFIDENCE \u2192 OVERRIDE\n    Direction = MODERATE_UPWARD\n    Batch size = 0.15 (small hedge)\n    Reason = "OVERRIDE_small_hedge_mod_upward_net0.98%_cv2.8%"\n\n  Inventory = 40 tons\n  Sell 40 \xd7 0.15 = 6 tons\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Marshall et al. (2008)"})," for baseline threshold strategy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Williams & Wright (1991)"})," ",(0,r.jsx)(n.em,{children:"Storage and Commodity Markets"})," for cost-benefit framework"]}),"\n",(0,r.jsx)(n.li,{children:'Confidence weighting described as "novel extension"'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Inherits all baseline parameters from PriceThresholdStrategy"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"high_confidence_cv"}),": 0.05 (5%)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"medium_confidence_cv"}),": 0.15 (15%)"]}),"\n",(0,r.jsx)(n.li,{children:"`strong_positive_threshold: 2.0 (text: greater than 2 percent net benefit)"}),"\n",(0,r.jsx)(n.li,{children:"`strong_negative_threshold: -1.0 (text: less than -1 percent net benefit)"}),"\n",(0,r.jsx)(n.li,{children:"`moderate_threshold: 0.5 (text: plus or minus 0.5 percent)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_pred_hold"}),": 0.0"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_pred_aggressive"}),": 0.40"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_pred_cautious"}),": 0.15"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"6-moving-average-predictive-matched-pair",children:"6. Moving Average Predictive (Matched Pair)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"prediction.py:387-729"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Augment Moving Average baseline with forecast-driven overrides."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Same 3-tier confidence system"})," as Price Threshold Predictive, but baseline is MA crossover instead of price threshold."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Logic"}),": Identical structure to Price Threshold Predictive, but ",(0,r.jsx)(n.code,{children:"_execute_baseline_logic()"})," implements MA crossover detection."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),": Same as Price Threshold Predictive."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"7-expected-value-strategy-standalone",children:"7. Expected Value Strategy (Standalone)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"prediction.py:736-866"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Optimize expected value across all forecast horizons."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. For each of 14 forecast days:\n   a. Calculate expected revenue = median(predictions) - costs\n2. Find day with maximum expected value\n3. Calculate net benefit vs selling today\n4. Decision based on:\n   - Net benefit magnitude\n   - Prediction confidence (CV)\n   - Trend strength (ADX)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimal Sale Day Calculation"})," (",(0,r.jsx)(n.code,{children:"prediction.py:841-857"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _find_optimal_sale_day_pct(self, current_price, predictions):\n    # predictions is (2000 paths \xd7 14 days)\n\n    ev_by_day = []\n    for day in range(14):\n        # Use median of 2,000 paths as expected price\n        future_price = np.median(predictions[:, day])\n        days_to_wait = day + 1\n\n        # Calculate costs\n        storage_cost = current_price * (self.storage_cost_pct_per_day / 100) * days_to_wait\n        transaction_cost = future_price * (self.transaction_cost_pct / 100)\n\n        # Expected value if we sell on this day\n        ev = future_price - storage_cost - transaction_cost\n        ev_by_day.append(ev)\n\n    # Compare to selling today\n    transaction_cost_today = current_price * (self.transaction_cost_pct / 100)\n    ev_today = current_price - transaction_cost_today\n\n    # Find best option\n    optimal_day = np.argmax(ev_by_day)\n    net_benefit_pct = 100 * (ev_by_day[optimal_day] - ev_today) / current_price\n\n    return optimal_day, net_benefit_pct\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Based on Net Benefit"})," (",(0,r.jsx)(n.code,{children:"prediction.py:805-839"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_expected_value_pct(self, current_price, price_history, predictions):\n    optimal_day, net_benefit_pct = self._find_optimal_sale_day_pct(current_price, predictions)\n\n    # Calculate confidence\n    cv = calculate_prediction_confidence(predictions, horizon_day=13)  # Day 14\n    adx, _, _ = calculate_adx(price_history, period=14)\n\n    # Decision based on net benefit magnitude\n    if net_benefit_pct greater than self.min_net_benefit_pct:  # greater than 0.5%\n        # Positive net benefit (waiting is better)\n\n        if cv < self.high_confidence_cv and adx greater than self.strong_trend_adx:\n            # High confidence + strong trend - hold all\n            batch_size = self.batch_positive_confident  # 0.0\n            reason = f'net_benefit_{net_benefit_pct:.2f}%_high_conf_hold_to_day{optimal_day}'\n\n        elif cv < self.medium_confidence_cv:\n            # Medium confidence - small hedge\n            batch_size = self.batch_positive_uncertain  # 0.10\n            reason = f'net_benefit_{net_benefit_pct:.2f}%_med_conf_small_hedge_day{optimal_day}'\n\n        else:\n            # Low confidence - larger hedge\n            batch_size = self.batch_marginal  # 0.15\n            reason = f'net_benefit_{net_benefit_pct:.2f}%_low_conf_hedge'\n\n    elif net_benefit_pct greater than 0:  # Marginal benefit (0% to 0.5%)\n        batch_size = self.batch_marginal  # 0.15\n        reason = f'marginal_benefit_{net_benefit_pct:.2f}%_gradual_liquidation'\n\n    elif net_benefit_pct greater than self.negative_threshold_pct:  # -0.3% to 0%\n        # Mild negative (sell today slightly better)\n        batch_size = self.batch_negative_mild  # 0.25\n        reason = f'mild_negative_{net_benefit_pct:.2f}%_avoid_storage'\n\n    else:  # less than -0.3%\n        # Strong negative (sell immediately much better)\n        batch_size = self.batch_negative_strong  # 0.35\n        reason = f'strong_negative_{net_benefit_pct:.2f}%_sell_to_cut_losses'\n\n    return batch_size, reason\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Calculation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Current price: $2.00/lb = $4,000/ton\nInventory: 50 tons\n\nPredictions (2,000 paths \xd7 14 days):\nDay 1:  Median = $2.01/lb = $4,020/ton\nDay 7:  Median = $2.05/lb = $4,100/ton\nDay 14: Median = $2.08/lb = $4,160/ton\n\nCalculate EV for each day:\n\nDay 1:\n  Future price: $4,020/ton\n  Storage cost: $4,000 \xd7 (0.005/100) \xd7 1 = $0.20/ton\n  Transaction cost: $4,020 \xd7 (0.01/100) = $0.40/ton\n  EV = $4,020 - $0.20 - $0.40 = $4,019.40/ton\n\nDay 7:\n  Future price: $4,100/ton\n  Storage cost: $4,000 \xd7 (0.005/100) \xd7 7 = $1.40/ton\n  Transaction cost: $4,100 \xd7 (0.01/100) = $0.41/ton\n  EV = $4,100 - $1.40 - $0.41 = $4,098.19/ton\n\nDay 14:\n  Future price: $4,160/ton\n  Storage cost: $4,000 \xd7 (0.005/100) \xd7 14 = $2.80/ton\n  Transaction cost: $4,160 \xd7 (0.01/100) = $0.42/ton\n  EV = $4,160 - $2.80 - $0.42 = $4,156.78/ton  \u2190 BEST\n\nSell today:\n  Price: $4,000/ton\n  Transaction cost: $4,000 \xd7 (0.01/100) = $0.40/ton\n  EV = $4,000 - $0.40 = $3,999.60/ton\n\nNet benefit = ($4,156.78 - $3,999.60) / $4,000 \xd7 100 = 3.93%\n\nConfidence:\n  CV at day 14 = 0.04 = 4% \u2192 HIGH CONFIDENCE\n  ADX = 30 \u2192 STRONG TREND\n\nDecision:\n  Net benefit = 3.93% greater than 0.5% (positive)\n  CV = 4% < 5% (high confidence)\n  ADX = 30 greater than 25 (strong trend)\n\n  \u2192 batch_size = 0.0 (HOLD all)\n  \u2192 reason = "net_benefit_3.93%_high_conf_hold_to_day14"\n\nResult: HOLD all 50 tons (wait for day 14)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Williams, J. C., & Wright, B. D. (1991)."})," ",(0,r.jsx)(n.em,{children:"Storage and Commodity Markets."})," Cambridge University Press.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ISBN: 9780521326162"}),"\n",(0,r.jsx)(n.li,{children:"Comprehensive treatment of commodity storage decisions with uncertainty"}),"\n",(0,r.jsx)(n.li,{children:"PERFECT fit for this strategy"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"storage_cost_pct_per_day"}),": Inherited from config"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transaction_cost_pct"}),": Inherited from config"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_net_benefit_pct"}),": 0.5 (0.5% minimum)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"negative_threshold_pct"}),": -0.3 (-0.3%)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"high_confidence_cv"}),": 0.05 (5%)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"medium_confidence_cv"}),": 0.10 (10%)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"strong_trend_adx"}),": 25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_positive_confident"}),": 0.0"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_positive_uncertain"}),": 0.10"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_marginal"}),": 0.15"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_negative_mild"}),": 0.25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_negative_strong"}),": 0.35"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldown_days"}),": 7"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"baseline_batch"}),": 0.15"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"baseline_frequency"}),": 30"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Academically grounded (Williams & Wright 1991)"}),"\n",(0,r.jsx)(n.li,{children:"Optimal from cost-benefit perspective"}),"\n",(0,r.jsx)(n.li,{children:"Accounts for storage costs rising linearly with time"}),"\n",(0,r.jsx)(n.li,{children:"Uses ensemble median (robust to outliers)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"8-consensus-strategy-standalone",children:"8. Consensus Strategy (Standalone)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"prediction.py:873-1028"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Democratic vote across 2,000 forecast paths."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Count % of paths showing sufficient return (greater than 3%)\n2. If \u226570% bullish AND net benefit greater than threshold: HOLD\n3. If <30% bullish (bearish consensus): SELL aggressively\n4. Batch size modulated by consensus strength\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consensus Calculation"})," (",(0,r.jsx)(n.code,{children:"prediction.py:963-1019"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_consensus_pct(self, current_price, price_history, predictions):\n    # Evaluate at day 14\n    eval_day = min(self.evaluation_day, predictions.shape[1] - 1)\n    day_predictions = predictions[:, eval_day]  # 2,000 values\n\n    # Calculate expected return\n    median_future = np.median(day_predictions)\n    expected_return_pct = (median_future - current_price) / current_price\n\n    # Count bullish predictions (those showing greater than 3% return)\n    bullish_count = np.sum(\n        (day_predictions - current_price) / current_price greater than self.min_return  # 3%\n    )\n    bullish_pct = bullish_count / len(day_predictions)  # 0.0 to 1.0\n\n    # Calculate confidence\n    cv = calculate_prediction_confidence(predictions, eval_day)\n\n    # Calculate net benefit (accounting for costs)\n    days_to_wait = eval_day + 1\n    storage_cost_pct = (self.storage_cost_pct_per_day / 100) * days_to_wait\n    transaction_cost_pct = self.transaction_cost_pct / 100\n    net_benefit_pct = 100 * (expected_return_pct - storage_cost_pct - transaction_cost_pct)\n\n    # Decision based on consensus strength\n    if bullish_pct greater than or equal to  self.very_strong_consensus and net_benefit_pct greater than self.min_net_benefit_pct:\n        # Very strong consensus (85%+ bullish) + positive net benefit\n        batch_size = self.batch_strong_consensus  # 0.0\n        reason = f'very_strong_consensus_{bullish_pct:.0%}_net_{net_benefit_pct:.2f}%_hold'\n\n    elif bullish_pct greater than or equal to  self.consensus_threshold and net_benefit_pct greater than self.min_net_benefit_pct:\n        # Strong consensus (70%+ bullish) + positive net benefit\n        if cv < self.high_confidence_cv:\n            batch_size = self.batch_strong_consensus  # 0.0\n            reason = f'strong_consensus_{bullish_pct:.0%}_high_conf_hold'\n        else:\n            batch_size = self.batch_moderate  # 0.15\n            reason = f'strong_consensus_{bullish_pct:.0%}_med_conf_gradual'\n\n    elif bullish_pct greater than or equal to  self.moderate_consensus:\n        # Moderate consensus (60%+ bullish)\n        batch_size = self.batch_moderate  # 0.15\n        reason = f'moderate_consensus_{bullish_pct:.0%}_gradual'\n\n    elif bullish_pct < (1 - self.consensus_threshold):\n        # Bearish consensus (< 30% bullish, i.e., greater than 70% bearish)\n        batch_size = self.batch_bearish  # 0.35\n        reason = f'bearish_consensus_{bullish_pct:.0%}_sell'\n\n    else:\n        # Weak/unclear consensus (30-60% bullish)\n        batch_size = self.batch_weak  # 0.25\n        reason = f'weak_consensus_{bullish_pct:.0%}_sell'\n\n    return batch_size, reason\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Predictions at day 14: 2,000 paths\nCurrent price: $2.00/lb\n\nPath-by-path analysis:\nPath 1: $2.08/lb \u2192 Return = 4.0% \u2192 BULLISH (greater than 3%)\nPath 2: $2.05/lb \u2192 Return = 2.5% \u2192 BEARISH (< 3%)\nPath 3: $2.10/lb \u2192 Return = 5.0% \u2192 BULLISH\nPath 4: $2.02/lb \u2192 Return = 1.0% \u2192 BEARISH\n...\nPath 2000: $2.07/lb \u2192 Return = 3.5% \u2192 BULLISH\n\nCount:\nBullish paths: 1,700\nBearish paths: 300\nBullish percentage: 1,700 / 2,000 = 85%\n\nStatistics:\nMedian = $2.08/lb\nStd dev = $0.06/lb\nCV = $0.06 / $2.08 = 0.029 = 2.9% \u2192 HIGH CONFIDENCE\n\nExpected return = ($2.08 - $2.00) / $2.00 = 4.0%\nStorage cost (14 days) = 0.005% \xd7 14 = 0.07%\nTransaction cost = 0.01%\nNet benefit = 4.0% - 0.07% - 0.01% = 3.92%\n\nDecision:\nBullish% = 85% greater than or equal to  85% (very strong consensus)\nNet benefit = 3.92% greater than 0.5%\n\n\u2192 batch_size = 0.0 (HOLD all)\n\u2192 reason = "very_strong_consensus_85%_net_3.92%_hold"\n\nResult: HOLD all inventory\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clemen, R. T. (1989)."}),' "Combining forecasts: A review and annotated bibliography." ',(0,r.jsx)(n.em,{children:"International Journal of Forecasting"}),", 5(4), 559-583.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"DOI: 10.1016/0169-2070(89)90012-5"}),"\n",(0,r.jsx)(n.li,{children:"2,165+ citations"}),"\n",(0,r.jsx)(n.li,{children:'Key finding: "Forecast accuracy can be substantially improved through combination of multiple individual forecasts"'}),"\n",(0,r.jsx)(n.li,{children:"EXCELLENT fit for ensemble/consensus methodology"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"storage_cost_pct_per_day"}),": Inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transaction_cost_pct"}),": Inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consensus_threshold"}),": 0.70 (70% agreement)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"very_strong_consensus"}),": 0.85 (85% agreement)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"moderate_consensus"}),": 0.60 (60% agreement)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_return"}),': 0.03 (3% return threshold for "bullish")']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_net_benefit_pct"}),": 0.5 (0.5% minimum)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"high_confidence_cv"}),": 0.05 (5%)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"evaluation_day"}),": 14"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_strong_consensus"}),": 0.0"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_moderate"}),": 0.15"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_weak"}),": 0.25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_bearish"}),": 0.35"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldown_days"}),": 7"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensemble voting robust to individual model errors"}),"\n",(0,r.jsx)(n.li,{children:"Leverages full distribution (not just median)"}),"\n",(0,r.jsx)(n.li,{children:"Captures market uncertainty through consensus strength"}),"\n",(0,r.jsx)(n.li,{children:"Democratic approach reduces impact of outliers"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"9-risk-adjusted-strategy-standalone",children:"9. Risk-Adjusted Strategy (Standalone)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"prediction.py:1035-1190"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Balance expected return vs forecast uncertainty (Sharpe ratio approach)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Algorithm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Calculate expected return as percentage\n2. Measure prediction uncertainty (CV)\n3. Classify into risk tiers:\n   - Low risk (CV < 5% + strong trend): HOLD all\n   - Medium risk (CV < 10%): Small hedge\n   - High risk (CV < 20%): Larger hedge\n   - Very high risk (CV \u2265 20%): Sell aggressively\n4. Decision based on return/risk tradeoff\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk-Adjusted Decision"})," (",(0,r.jsx)(n.code,{children:"prediction.py:1125-1181"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _analyze_risk_adjusted_pct(self, current_price, price_history, predictions):\n    # Evaluate at day 14\n    eval_day = min(self.evaluation_day, predictions.shape[1] - 1)\n    day_predictions = predictions[:, eval_day]  # 2,000 values\n\n    # Calculate expected return\n    median_future = np.median(day_predictions)\n    expected_return_pct = (median_future - current_price) / current_price\n\n    # Measure uncertainty (risk)\n    cv = calculate_prediction_confidence(predictions, eval_day)\n    # cv = std_dev / median\n    # Low risk: cv < 0.05 (5%)\n    # Medium risk: cv < 0.10 (10%)\n    # High risk: cv < 0.20 (20%)\n    # Very high risk: cv greater than or equal to  0.20\n\n    # Calculate net benefit (accounting for costs)\n    days_to_wait = eval_day + 1\n    storage_cost_pct = (self.storage_cost_pct_per_day / 100) * days_to_wait\n    transaction_cost_pct = self.transaction_cost_pct / 100\n    net_benefit_pct = 100 * (expected_return_pct - storage_cost_pct - transaction_cost_pct)\n\n    # Get trend strength\n    adx, _, _ = calculate_adx(price_history, period=min(14, len(price_history)-1))\n\n    # Check if return is sufficient\n    if expected_return_pct greater than or equal to  self.min_return and net_benefit_pct greater than self.min_net_benefit_pct:\n        # Sufficient return - tier by risk\n\n        if cv < self.max_uncertainty_low and adx greater than self.strong_trend_adx:\n            # Low risk + strong trend\n            batch_size = self.batch_low_risk  # 0.0\n            reason = f'low_risk_cv{cv:.2%}_return{expected_return_pct:.2%}_hold'\n\n        elif cv < self.max_uncertainty_medium:\n            # Medium risk\n            batch_size = self.batch_medium_risk  # 0.10\n            reason = f'medium_risk_cv{cv:.2%}_return{expected_return_pct:.2%}_small_hedge'\n\n        elif cv < self.max_uncertainty_high:\n            # High risk\n            batch_size = self.batch_high_risk  # 0.25\n            reason = f'high_risk_cv{cv:.2%}_return{expected_return_pct:.2%}_hedge'\n\n        else:\n            # Very high risk\n            batch_size = self.batch_very_high_risk  # 0.35\n            reason = f'very_high_risk_cv{cv:.2%}_sell'\n\n    else:\n        # Insufficient return or negative net benefit\n        if net_benefit_pct < 0:\n            batch_size = self.batch_very_high_risk  # 0.35\n            reason = f'negative_net_benefit_{net_benefit_pct:.2f}%_sell'\n        else:\n            batch_size = self.batch_high_risk  # 0.25\n            reason = f'insufficient_return_{expected_return_pct:.2%}_sell'\n\n    return batch_size, reason\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk-Tiered Examples"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Scenario A: Low Risk, High Return\n  Current price: $2.00/lb\n  Day 14 predictions (2,000 paths):\n    Median: $2.10/lb\n    Std dev: $0.06/lb\n    CV = $0.06 / $2.10 = 0.029 = 2.9% \u2192 LOW RISK\n\n  Expected return = ($2.10 - $2.00) / $2.00 = 5.0%\n  Net benefit = 5.0% - 0.07% - 0.01% = 4.92%\n  ADX = 30 \u2192 STRONG TREND\n\n  Decision:\n    Expected return 5.0% greater than or equal to  3.0% \u2713\n    Net benefit 4.92% greater than 0.5% \u2713\n    CV 2.9% < 5.0% \u2192 LOW RISK \u2713\n    ADX 30 greater than 25 \u2192 STRONG TREND \u2713\n\n  \u2192 batch_size = 0.0 (HOLD all)\n  \u2192 reason = "low_risk_cv2.9%_return5.0%_hold"\n\n---\n\nScenario B: High Risk, High Return\n  Current price: $2.00/lb\n  Day 14 predictions (2,000 paths):\n    Median: $2.10/lb\n    Std dev: $0.38/lb\n    CV = $0.38 / $2.10 = 0.18 = 18% \u2192 HIGH RISK\n\n  Expected return = 5.0%\n  Net benefit = 4.92%\n\n  Decision:\n    Expected return 5.0% greater than or equal to  3.0% \u2713\n    Net benefit 4.92% greater than 0.5% \u2713\n    CV 18% < 20% \u2192 HIGH RISK\n\n  \u2192 batch_size = 0.25 (hedge 25%)\n  \u2192 reason = "high_risk_cv18%_return5.0%_hedge"\n\n---\n\nScenario C: Low Risk, Low Return\n  Current price: $2.00/lb\n  Day 14 predictions:\n    Median: $2.04/lb\n    CV = 3% \u2192 LOW RISK\n\n  Expected return = ($2.04 - $2.00) / $2.00 = 2.0%\n  Net benefit = 2.0% - 0.07% - 0.01% = 1.92%\n\n  Decision:\n    Expected return 2.0% < 3.0% \u2717 (insufficient)\n    Net benefit 1.92% greater than 0.5% \u2713 (positive but below threshold)\n\n  \u2192 batch_size = 0.25\n  \u2192 reason = "insufficient_return_2.0%_sell"\n\n---\n\nScenario D: High Risk, Low Return\n  Current price: $2.00/lb\n  Day 14 predictions:\n    Median: $2.04/lb\n    CV = 22% \u2192 VERY HIGH RISK\n\n  Expected return = 2.0%\n\n  Decision:\n    Expected return 2.0% < 3.0% \u2717\n    CV 22% greater than or equal to  20% \u2192 VERY HIGH RISK\n\n  \u2192 batch_size = 0.35 (aggressive sell)\n  \u2192 reason = "very_high_risk_cv22%_sell"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Markowitz, H. (1952)."}),' "Portfolio selection." ',(0,r.jsx)(n.em,{children:"Journal of Finance"}),", 7(1), 77-91.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"DOI: 10.1111/j.1540-6261.1952.tb01525.x"}),"\n",(0,r.jsx)(n.li,{children:"5,254+ citations"}),"\n",(0,r.jsx)(n.li,{children:"Nobel Prize winner (1990)"}),"\n",(0,r.jsx)(n.li,{children:"PERFECT fit - strategy directly implements mean-variance optimization using CV for risk"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"storage_cost_pct_per_day"}),": Inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transaction_cost_pct"}),": Inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_return"}),": 0.03 (3% minimum return)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_net_benefit_pct"}),": 0.5 (0.5% minimum)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_uncertainty_low"}),": 0.05 (CV < 5% = low risk)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_uncertainty_medium"}),": 0.10 (CV < 10% = medium risk)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_uncertainty_high"}),": 0.20 (CV < 20% = high risk)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"strong_trend_adx"}),": 25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"evaluation_day"}),": 14"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_low_risk"}),": 0.0"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_medium_risk"}),": 0.10"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_high_risk"}),": 0.25"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch_very_high_risk"}),": 0.35"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldown_days"}),": 7"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implements Markowitz mean-variance framework"}),"\n",(0,r.jsx)(n.li,{children:"Risk-adjusted returns (similar to Sharpe ratio)"}),"\n",(0,r.jsx)(n.li,{children:"Balances greed (expected return) with fear (uncertainty)"}),"\n",(0,r.jsx)(n.li,{children:"CV provides scale-invariant risk measure"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"optimization-strategy",children:"Optimization Strategy"}),"\n",(0,r.jsx)(n.h3,{id:"10-rolling-horizon-mpc-model-predictive-control",children:"10. Rolling Horizon MPC (Model Predictive Control)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File"}),": ",(0,r.jsx)(n.code,{children:"rolling_horizon_mpc.py:39-290"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Optimal control with limited foresight using linear programming."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Concept: Receding Horizon Control"})}),"\n",(0,r.jsx)(n.p,{children:"Traditional optimization problem:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Given: Full price trajectory for 365 days\nFind: Optimal sell schedule for all 365 days\nProblem: We don't have perfect foresight!\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rolling Horizon MPC:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 0: See prices for days 1-14\n       Solve optimization for days 1-14\n       Execute ONLY day 1 decision\n\nDay 1: See prices for days 2-15\n       Solve optimization for days 2-15\n       Execute ONLY day 2 decision\n\n... roll forward daily\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Logic"})," (",(0,r.jsx)(n.code,{children:"rolling_horizon_mpc.py:77-179"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def decide(self, day, inventory, current_price, price_history, predictions=None):\n    \"\"\"\n    Solve 14-day local optimization, execute first decision only.\n    \"\"\"\n    if inventory less than or equal to  0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_inventory'}\n\n    if predictions is None or len(predictions) == 0:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'no_predictions'}\n\n    # Get forecast window (14 days)\n    if len(predictions.shape) == 2:\n        # predictions is (2000 paths, 14 days) matrix\n        available_horizon = predictions.shape[1]\n    else:\n        # predictions is 1D array (single path)\n        available_horizon = len(predictions)\n\n    window_len = min(self.horizon_days, available_horizon)  # min(14, available)\n\n    if window_len less than or equal to  0:\n        return {'action': 'SELL', 'amount': inventory, 'reason': 'no_forecast_horizon'}\n\n    # Get predicted prices for the window (use mean of 2,000 paths)\n    if len(predictions.shape) == 2:\n        future_prices_cents = predictions[:, :window_len].mean(axis=0)\n    else:\n        future_prices_cents = predictions[:window_len]\n\n    # Convert cents/lb to $/ton\n    future_prices_per_ton = future_prices_cents * 20  # 2000 lbs = 1 ton\n\n    # Future harvest (zeros - BacktestEngine handles harvest externally)\n    future_harvest = np.zeros(window_len)\n\n    # Solve local LP for this window\n    result = self._solve_window_lp(\n        current_inventory=inventory,\n        future_prices=future_prices_per_ton,\n        future_harvest=future_harvest\n    )\n\n    if result is None or result['sell_solution'] is None:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'lp_failed'}\n\n    # EXECUTE ONLY THE FIRST DECISION (Receding Horizon)\n    sell_today = result['sell_solution'][0]\n\n    # Update shadow price if using shadow pricing\n    if self.shadow_price_smoothing is not None and result.get('shadow_price') is not None:\n        if self.smoothed_shadow_price is None:\n            self.smoothed_shadow_price = result['shadow_price']\n        else:\n            # Exponential smoothing\n            alpha = self.shadow_price_smoothing\n            self.smoothed_shadow_price = (alpha * result['shadow_price'] +\n                                         (1 - alpha) * self.smoothed_shadow_price)\n\n    # Threshold to avoid tiny sales\n    if sell_today < 0.1:\n        return {'action': 'HOLD', 'amount': 0, 'reason': 'mpc_hold'}\n\n    # Sell amount (capped at current inventory)\n    sell_amount = min(sell_today, inventory)\n\n    return {\n        'action': 'SELL',\n        'amount': sell_amount,\n        'reason': 'mpc_optimize',\n        'window_len': window_len,\n        'predicted_net_value': result.get('objective_value', 0)\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Linear Programming Formulation"})," (",(0,r.jsx)(n.code,{children:"rolling_horizon_mpc.py:181-290"}),"):"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision Variables"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x = [sell[0], sell[1], ..., sell[13],  # Amount to sell each day\n     inv[0], inv[1], ..., inv[13]]      # Inventory at end of each day\n"})}),"\n",(0,r.jsx)(n.p,{children:"Total: 28 variables (14 sell + 14 inventory)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Objective Function"})," (maximize profit):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Revenue - Transaction Costs\nrevenue = \u03a3(sell[t] \xd7 price[t] \xd7 (1 - transaction_cost%))\n\n# Storage Costs\nstorage = \u03a3(inv[t] \xd7 price[t] \xd7 storage_cost_pct_per_day)\n\n# Objective: maximize revenue - storage\nobjective = revenue - storage\n\n# LP minimizes, so negate\nminimize: -revenue + storage\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Constraints"})," (inventory balance):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# For each day t:\n# sell[t] + inv[t] - inv[t-1] = harvest[t]\n\nDay 0: sell[0] + inv[0] = current_inventory + harvest[0]\nDay 1: sell[1] + inv[1] - inv[0] = harvest[1]\nDay 2: sell[2] + inv[2] - inv[1] = harvest[2]\n...\nDay 13: sell[13] + inv[13] - inv[12] = harvest[13]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bounds"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"sell[t] greater than or equal to  0  for all t\ninv[t] greater than or equal to  0   for all t\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LP Solve Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _solve_window_lp(self, current_inventory, future_prices, future_harvest):\n    \"\"\"\n    Solve the local LP optimization for the forecast window.\n\n    Args:\n        current_inventory: Starting inventory (tons)\n        future_prices: Array of predicted prices ($/ton) for 14 days\n        future_harvest: Array of harvest increments (tons) for 14 days\n\n    Returns:\n        Dict with sell_solution, inventory_solution, objective_value, shadow_price\n    \"\"\"\n    n_days = len(future_prices)  # 14\n\n    # Decision variables: [sell[0], ..., sell[13], inv[0], ..., inv[13]]\n    var_sell_start = 0\n    var_inv_start = n_days\n\n    # Objective function coefficients\n    c = np.zeros(2 * n_days)  # 28 variables\n\n    # Revenue (negative because we minimize)\n    revenue_coeff = future_prices * (1 - self.transaction_cost_pct / 100)\n    c[var_sell_start:var_inv_start] = -revenue_coeff\n\n    # Storage costs (positive)\n    storage_coeff = future_prices * (self.storage_cost_pct_per_day / 100)\n    c[var_inv_start:] = storage_coeff\n\n    # Constraints: A_eq * x = b_eq\n    A_eq = []\n    b_eq = []\n\n    for t in range(n_days):\n        row = np.zeros(2 * n_days)\n\n        # Inventory balance: sell[t] + inv[t] - inv[t-1] = harvest[t]\n        row[var_sell_start + t] = 1  # sell[t]\n        row[var_inv_start + t] = 1   # inv[t]\n\n        if t greater than 0:\n            row[var_inv_start + t - 1] = -1  # inv[t-1]\n            b_eq.append(future_harvest[t])\n        else:\n            # Day 0: sell[0] + inv[0] = current_inventory + harvest[0]\n            b_eq.append(current_inventory + future_harvest[t])\n\n        A_eq.append(row)\n\n    A_eq = np.array(A_eq)\n    b_eq = np.array(b_eq)\n\n    # CRITICAL: Add terminal value to objective\n    # This prevents End-of-Horizon effect (myopic liquidation)\n    if self.shadow_price_smoothing is not None and self.smoothed_shadow_price is not None:\n        # Use smoothed shadow price as terminal value\n        terminal_val_coeff = -self.smoothed_shadow_price\n        c[var_inv_start + n_days - 1] += terminal_val_coeff\n    else:\n        # Use simple price-based terminal value with decay\n        terminal_val_coeff = -future_prices[-1] * self.terminal_value_decay\n        c[var_inv_start + n_days - 1] += terminal_val_coeff\n\n    # Bounds: all variables greater than or equal to  0\n    bounds = [(0, None) for _ in range(2 * n_days)]\n\n    # Solve LP using scipy.optimize.linprog\n    try:\n        result = linprog(\n            c=c,\n            A_eq=A_eq,\n            b_eq=b_eq,\n            bounds=bounds,\n            method='highs',\n            options={'disp': False, 'presolve': True}\n        )\n\n        if not result.success:\n            return None\n\n        # Extract solution\n        sell_solution = result.x[var_sell_start:var_inv_start]\n        inv_solution = result.x[var_inv_start:]\n\n        # Extract shadow price (approximate)\n        shadow_price = future_prices[-1] * self.terminal_value_decay\n\n        return {\n            'sell_solution': sell_solution,\n            'inventory_solution': inv_solution,\n            'objective_value': -result.fun,  # Negate back to profit\n            'shadow_price': shadow_price\n        }\n\n    except Exception as e:\n        print(f\"Rolling Horizon LP failed: {e}\")\n        return None\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Critical: Terminal Value Correction"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Without terminal value, LP liquidates everything by day 14 (myopic)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why?"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Day 14 inventory has zero value in objective\nLP thinks: "Sell everything by day 14, inventory is worthless after"\nResult: Suboptimal early liquidation\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Add terminal value to inventory remaining at day 14."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simple approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Use future price with decay\nterminal_value_coeff = -future_prices[13] \xd7 0.95  # 95% of day 14 price\nc[inv[13]] += terminal_value_coeff  # Add to objective\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advanced approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Use shadow prices (smoothed dual variable from previous LP solves)\nif shadow_price_smoothing:\n    terminal_value_coeff = -smoothed_shadow_price\n    c[inv[13]] += terminal_value_coeff\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Execution"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 0:\n  Current inventory: 50 tons\n  Forecast (2,000 paths \xd7 14 days):\n    Mean prices = [4000, 4020, 4040, ..., 4280] $/ton\n\n  LP setup:\n    Variables: [sell[0], ..., sell[13], inv[0], ..., inv[13]]\n\n    Objective:\n      Revenue = sell[0]\xd74000 + sell[1]\xd74020 + ... + sell[13]\xd74280\n      Transaction costs = sell[0]\xd740 + sell[1]\xd740.2 + ... + sell[13]\xd742.8\n      Storage costs = inv[0]\xd70.2 + inv[1]\xd70.201 + ... + inv[13]\xd70.214\n      Terminal value = inv[13] \xd7 4280 \xd7 0.95 = inv[13] \xd7 4066\n\n    Constraints:\n      sell[0] + inv[0] = 50\n      sell[1] + inv[1] - inv[0] = 0\n      ...\n      sell[13] + inv[13] - inv[12] = 0\n\n    Bounds:\n      All variables greater than or equal to  0\n\n  LP solves:\n    sell = [5.2, 4.8, 6.1, ..., 3.1] tons\n    inv = [44.8, 40.0, 33.9, ..., 8.5] tons\n    objective = $195,432\n\n  Execute ONLY sell[0] = 5.2 tons\n\nDay 1:\n  Current inventory: 50 - 5.2 = 44.8 tons\n  Forecast (new 14-day window):\n    Mean prices = [4020, 4040, 4060, ..., 4300] $/ton (updated!)\n\n  LP solves again with new prices:\n    sell = [3.9, 5.2, 4.7, ..., 2.8] tons  (different from yesterday!)\n    ...\n\n  Execute ONLY sell[0] = 3.9 tons\n\n... continues rolling forward\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Academic References"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secomandi, N. (2010)."}),' "Optimal Commodity Trading with a Capacitated Storage Asset." ',(0,r.jsx)(n.em,{children:"Management Science"}),", 56(3), 449-467.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"DOI: 10.1287/mnsc.1090.1049"}),"\n",(0,r.jsx)(n.li,{children:"Carnegie Mellon University"}),"\n",(0,r.jsx)(n.li,{children:"Addresses warehouse problem with finite horizons and terminal boundary conditions"}),"\n",(0,r.jsx)(n.li,{children:"Optimal inventory-trading policy with stage-dependent basestock targets"}),"\n",(0,r.jsx)(n.li,{children:"BEST match for MPC approach"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Williams, J. C., & Wright, B. D. (1991)."})," ",(0,r.jsx)(n.em,{children:"Storage and Commodity Markets."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Alternative citation for agricultural commodity storage framework"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"storage_cost_pct_per_day"}),": 0.3% (default for MPC)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transaction_cost_pct"}),": 2.0% (default for MPC)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"horizon_days"}),": 14"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"terminal_value_decay"}),": 0.95 (95% of day 14 price)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"shadow_price_smoothing"}),": None (simple) or 0.3 (advanced)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why this design?"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Academically grounded (Secomandi 2010, Williams & Wright 1991)"}),"\n",(0,r.jsx)(n.li,{children:"Optimal given limited foresight"}),"\n",(0,r.jsx)(n.li,{children:"Terminal value prevents myopic liquidation"}),"\n",(0,r.jsx)(n.li,{children:"Expected performance: 85-95% of Oracle (perfect foresight)"}),"\n",(0,r.jsx)(n.li,{children:"Mimics Model Predictive Control from control theory"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"academic-references",children:"Academic References"}),"\n",(0,r.jsx)(n.p,{children:"Complete bibliography with all citations."}),"\n",(0,r.jsx)(n.h3,{id:"core-citations-high-impact",children:"Core Citations (High Impact)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1. Markowitz, H. (1952)."})," Portfolio selection. ",(0,r.jsx)(n.em,{children:"Journal of Finance"}),", 7(1), 77-91."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DOI"}),": 10.1111/j.1540-6261.1952.tb01525.x"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Citations"}),": 5,254+"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),": Nobel Prize winner (1990). Foundation of mean-variance optimization and modern portfolio theory."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Risk-Adjusted strategy (PERFECT fit)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2. Williams, J. C., & Wright, B. D. (1991)."})," ",(0,r.jsx)(n.em,{children:"Storage and commodity markets."})," Cambridge University Press."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ISBN"}),": 9780521326162"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pages"}),": 502"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),': Comprehensive treatment of commodity storage with uncertainty. Economic Journal: "Of major significance in the analysis of commodity markets."']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Expected Value strategy, Rolling Horizon MPC strategy"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"3. Marshall, B. R., Cahan, R. H., & Cahan, J. M. (2008)."})," Can commodity futures be profitably traded with quantitative market timing strategies? ",(0,r.jsx)(n.em,{children:"Journal of Banking & Finance"}),", 32(9), 1810-1819."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),": Comprehensive examination of quantitative trading rules in commodity futures. Tests 15 major commodity futures series."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Price Threshold, Moving Average, and their predictive variants"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"4. Clemen, R. T. (1989)."})," Combining forecasts: A review and annotated bibliography. ",(0,r.jsx)(n.em,{children:"International Journal of Forecasting"}),", 5(4), 559-583."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DOI"}),": 10.1016/0169-2070(89)90012-5"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Citations"}),": 2,165+"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),': Comprehensive review with 200+ item annotated bibliography. Key finding: "Forecast accuracy can be substantially improved through combination."']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Consensus strategy"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"5. Wilder, J. Welles (1978)."})," ",(0,r.jsx)(n.em,{children:"New concepts in technical trading systems."})," Trend Research."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pages"}),": 142"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),": Original source for RSI, ADX, Parabolic SAR, ATR. Considered one of the most innovative books on technical analysis."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Price Threshold and Moving Average strategies (technical indicators)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"6. Brock, W., Lakonishok, J., & LeBaron, B. (1992)."})," Simple technical trading rules and the stochastic properties of stock returns. ",(0,r.jsx)(n.em,{children:"Journal of Finance"}),", 47(5), 1731-1764."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DOI"}),": 10.1111/j.1540-6261.1992.tb04681.x"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Citations"}),": 2,200+"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),": Highly cited empirical study of technical trading rules. Validates MA strategies."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Moving Average strategy (optional - academic validation)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"7. Secomandi, N. (2010)."})," Optimal commodity trading with a capacitated storage asset. ",(0,r.jsx)(n.em,{children:"Management Science"}),", 56(3), 449-467."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DOI"}),": 10.1287/mnsc.1090.1049"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Author"}),": Tepper School of Business, Carnegie Mellon University"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),": Finite horizon dynamic programming for commodity storage. Stage-dependent basestock policies."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for"}),": Rolling Horizon MPC strategy"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"strategy-to-citation-mapping",children:"Strategy-to-Citation Mapping"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"#"}),(0,r.jsx)(n.th,{children:"Strategy"}),(0,r.jsx)(n.th,{children:"Primary Citation(s)"}),(0,r.jsx)(n.th,{children:"Quality"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Immediate Sale"}),(0,r.jsx)(n.td,{children:"None (naive baseline)"}),(0,r.jsx)(n.td,{children:"N/A"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Equal Batches"}),(0,r.jsx)(n.td,{children:"None found"}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Heuristic only"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Price Threshold"}),(0,r.jsx)(n.td,{children:"Marshall et al. (2008) + Wilder (1978)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"Moving Average"}),(0,r.jsx)(n.td,{children:"Marshall et al. (2008) + Wilder (1978)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"Threshold Predictive"}),(0,r.jsx)(n.td,{children:"Marshall (2008) + Williams & Wright (1991)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{children:"MA Predictive"}),(0,r.jsx)(n.td,{children:"Marshall (2008) + Williams & Wright (1991)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"7"}),(0,r.jsx)(n.td,{children:"Expected Value"}),(0,r.jsx)(n.td,{children:"Williams & Wright (1991)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{children:"Consensus"}),(0,r.jsx)(n.td,{children:"Clemen (1989)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"9"}),(0,r.jsx)(n.td,{children:"Risk-Adjusted"}),(0,r.jsx)(n.td,{children:"Markowitz (1952)"}),(0,r.jsx)(n.td,{children:"\u2705 PERFECT \u2b50"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"10"}),(0,r.jsx)(n.td,{children:"Rolling Horizon MPC"}),(0,r.jsx)(n.td,{children:"Secomandi (2010) or Williams & Wright (1991)"}),(0,r.jsx)(n.td,{children:"\u2705 VERIFIED"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"design-decisions",children:"Design Decisions"}),"\n",(0,r.jsx)(n.h3,{id:"why-3-tier-prediction-system",children:"Why 3-Tier Prediction System?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": How to use forecasts when confidence varies?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bad Approach"}),": Always follow predictions"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"if predicted_price greater than current_price:\n    return HOLD\nelse:\n    return SELL\n"})}),"\n",(0,r.jsx)(n.p,{children:"Problem: When CV = 30% (very uncertain), predictions are unreliable."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Good Approach"}),": Confidence-based blending"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"if cv < 0.05:  # HIGH confidence\n    # Override baseline completely\n    if predicted_upward:\n        return HOLD\nelif cv < 0.15:  # MEDIUM confidence\n    # Blend baseline + predictions\n    if baseline_sell and predicted_upward:\n        return SELL(amount * 0.5)  # Reduce baseline action\nelse:  # LOW confidence\n    # Ignore predictions, use baseline\n    return baseline_decision\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Fair matched-pair comparison shows value of predictions."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"why-coefficient-of-variation-cv",children:"Why Coefficient of Variation (CV)?"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CV = std_dev / median"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scale-invariant"}),": Works for $1/lb or $100/lb prices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Relative uncertainty"}),": 5% CV on $2.00 price = $0.10 std dev"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Industry standard"}),": Forecast evaluation metric"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Alternative (worse)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"uncertainty = std_dev  # Absolute dollars\n# Problem: $0.10 std dev is high for $1.00 price, low for $10.00 price\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"why-median-instead-of-mean",children:"Why Median Instead of Mean?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Forecast ensemble"}),": 2,000 price paths"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mean"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"mean_price = np.mean(predictions[:, day])  # Sensitive to outliers\n# If 1 path predicts $100, mean shifts significantly\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Median"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"median_price = np.median(predictions[:, day])  # Robust to outliers\n# Outliers don't affect median\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Median is more stable and robust."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"why-14-day-horizon",children:"Why 14-Day Horizon?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Forecast Agent"}),": Produces 14-day forecasts"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reasons"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Matches forecast capability"}),"\n",(0,r.jsx)(n.li,{children:"Computational efficiency (shorter horizon = faster LP solve)"}),"\n",(0,r.jsx)(n.li,{children:"Academic precedent (Secomandi 2010 uses 7-14 day windows)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"why-harvest-based-inventory",children:"Why Harvest-Based Inventory?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Traditional approach"})," (wrong):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 1: Start with 50 tons\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Realistic approach"})," (ours):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Day 1: Inventory = 0.327 tons (first day of harvest)\nDay 153: Inventory = 50 tons (end of harvest)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Models realistic producer behavior"}),"\n",(0,r.jsx)(n.li,{children:"Prevents unrealistic early liquidation"}),"\n",(0,r.jsx)(n.li,{children:"Accurate cost accounting (storage costs accumulate as inventory grows)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"force-liquidation",children:"Force Liquidation"}),"\n",(0,r.jsxs)(n.p,{children:["All strategies inherit from ",(0,r.jsx)(n.code,{children:"Strategy"})," base class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def _force_liquidation_check(self, day, inventory):\n    \"\"\"Sell all inventory at max_holding_days\"\"\"\n    if day greater than or equal to  self.max_holding_days:  # Usually 365\n        return {\n            'action': 'SELL',\n            'amount': inventory,\n            'reason': 'force_liquidation_max_days'\n        }\n    return None\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reason"}),": Quality degradation after 1 year."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"cooldown-periods",children:"Cooldown Periods"}),"\n",(0,r.jsx)(n.p,{children:"Most strategies use 7-day cooldown:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"if days_since_sale < self.cooldown_days:\n    return HOLD\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reason"}),": Prevents overtrading (transaction costs add up)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"batch-sizes",children:"Batch Sizes"}),"\n",(0,r.jsx)(n.p,{children:"All strategies use fractional batch sizes (0.0 to ~0.40):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"batch_size = 0.25  # Sell 25% of inventory\namount = inventory * batch_size\n\n# Example:\n# inventory = 50 tons\n# batch_size = 0.25\n# amount = 12.5 tons sold\n# remaining = 37.5 tons\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why fractions?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Gradual liquidation reduces risk"}),"\n",(0,r.jsx)(n.li,{children:"Avoids all-or-nothing decisions"}),"\n",(0,r.jsx)(n.li,{children:"Dollar-cost averaging benefit"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"parameter-optimization",children:"Parameter Optimization"}),"\n",(0,r.jsx)(n.p,{children:"All parameters can be optimized using Optuna:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Default parameters\nparams = {\n    'batch_size': 0.25,\n    'threshold_pct': 0.05,\n    ...\n}\n\n# Optimized parameters (from Optuna)\noptimized_params = load_from_json('optimized_params_coffee_model_v1.json')\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"parameter_manager.py"})," for automatic fallback logic."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,r.jsxs)(n.p,{children:["All strategies tested via ",(0,r.jsx)(n.code,{children:"BacktestEngine"})," with:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Harvest-based inventory (starts at zero, accumulates)"}),"\n",(0,r.jsx)(n.li,{children:"Cost modeling (storage + transaction)"}),"\n",(0,r.jsx)(n.li,{children:"Force liquidation (365 days max)"}),"\n",(0,r.jsx)(n.li,{children:"Multi-year backtests (2020-2024)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Statistical validation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Paired t-tests vs baselines"}),"\n",(0,r.jsx)(n.li,{children:"Bootstrap confidence intervals"}),"\n",(0,r.jsx)(n.li,{children:"Sign tests for consistency"}),"\n",(0,r.jsx)(n.li,{children:"Cohen's d for effect size"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"statistical_tests.py"})," (1,292 lines) for implementation."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Document Status"}),": \u2705 COMPLETE - Comprehensive technical reference\n",(0,r.jsx)(n.strong,{children:"Last Updated"}),": 2025-12-10\n",(0,r.jsx)(n.strong,{children:"Source Code"}),": ",(0,r.jsx)(n.code,{children:"/Users/markgibbons/capstone/ucberkeley-capstone/trading_agent/production/strategies/"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);